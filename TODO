Development principles:
=======================
   * Strive to always keep the game(s) playable without regression
   * Make as much of the engine configurable/overrideable as possible
   * Prefer existing libs over homegrown stuff
   * Copy from other sources in preference to re-invention
   * When inventing, do the least possible to get it working
   * When re-inventing, create something an order of magnitude better
   * Strive to abstract code into reusable libraries where sensible

Space Castle Development Objectives
===================================
1.  Produce a functional, distributable game that uses cairo
2.  Abstract a GameObject class, with reusable structure around it
3.  Abstract a Game class to use for future games

// 2010-05-06: 286 lines

Space Castle (Inspired by Star Castle / Yars Revenge)
============
* (DONE) Make both ctrl keys and space bar fire
* (DONE) Give a simple AI for the enemy ship
  - (DONE) Make it rotate to track the main player
* (DONE) Put into bzr

* Janitorial work
  - (DONE) canon -> cannon
  - (DONE) inkdrop.cpp -> spacecastle.cpp
  - Move on_expose_event() to Game, and simplify
  - Rewrite README
  - Move unrelated bits from TODO to elsewhere
  - Change is_turning_[left|right] to a turning_speed parameter
  - Make initial player position randomized
  - (DONE) Move sin/cos code into game-math.*
  - Move background and stars drawing into a draw_world() routine
  - Change game_over_message to "You Win" or "Space Castle Wins"
  - Refactor draw_flare() and draw_turning_flare() into one function
  - (DONE) Copy in path.*, point.h
  - Make sure all files have appropriate attribution
  - Change all x/y math to use the Point class (which is roughly similar
    to 2geom, to make transitioning easier)
  - Simplify the header includes
  - #ifdef debugging messages
  - Stock files:  AUTHORS, COPYING, MAINTAINERS, NEWS, ChangeLog
  - (DONE) Add a new minimal main.cpp like gnometris
  - (DONE) Remove stuff from ../inkdrop directory
  - Create some simple code to load config variables into an STL map
    + Google for configuration file loading code
    + Look in worldforge code
    + Look if I did this in any other of my game code already
    + Use plain KEY = VALUE maps for now

* Create top level game application object
  - (DONE) Move #defines into a game application object
  - Study gnometris field.*
  - Move static globals into game.cpp & declare in game.h
  - Add high score system
    + Adapt from gnome-games ?  See gnometris/scoreframe.*
    + Score is simply the time required to destroy the opponent
    + Save to ~/.config/games/$game/scores.txt
  - (DONE) Move scale_for_aspect_ratio()

* Create routine draw_path()
  - Review libgames-support/games-preimage.c, gnotravex/gnotravex.c,
    gnometris/renderer.cpp, gnometris/field.cpp, gnometris/preview.cpp
  - Takes a data structure
  - Makes multiple cairo_move_to(), cairo_curve_to(), cairo_line_to()
  - Integrate into draw_star, draw_ship_body, draw_missile
  - Derive from rsvg_cairo_render_path()
  - Decide how to handle color stops and fills
    + Review how Inkscape handles color
  - (DONE) Add path-parser.cpp, etc. to makefile and get it all to
    compile
  - Refactor spacecastle.cpp drawing code to use SVG path strings
    instead of direct cairo calls
  - Add Path objects into game object classes
  - Figure out how to handle patterns
  - Generalize the cairo text screen writing a bit more
* CanvasItem refactoring
  - (DONE) Make energy bars be drawn via CanvasItem::draw()
  - Make ship be drawn via CanvasItem::draw()
  - Make cannon be drawn via CanvasItem::draw()
  - Make missiles be drawn via CanvasItem::draw()
  - Make rings be drawn via CanvasItem::draw()
* Move constants to variables
  - Examine gnome-games games-conf.*/games-controls.* stuff
  - Investigate solutions for iparams/dparams
    + Review WorldForge code (didn't I solve this once before?)
    + Look through FreeCiv, LGeneral, pioneers, stratagus for similar
  - Implement dparam() and iparam() lookups
  - Implement define()
* Shields
  - (DONE) Revert shields from gradients to wedges
  - (DONE) Each wedge requires 2 hits to be destroyed
  - If the outer ring is destroyed, the next one will expand out to take 
    the place of the outer one
    + Need an animation sequence for this
    + Remove assumptions about where ring 0,1,2 are located
  - Once the shield segments are breached, the cannon can fire through
* AI for cannon
  - (DONE) Slowly track the player's ship at all times
  - Don't shoot if any of the three shields have full segments
  - In a given ring, calculate the segment # in front of the cannon's rotation
  - Don't shoot unless all the segments in front of cannon are missing
* Homing mines
  - There are 3 of them
  - Ship is damaged by contact with a mine
  - The mines can be shot and destroyed, but this is hard
  - Mines will continue circulating until destroyed
  - When a ring is regenerated, the mines are revived
  - AI for homing mines
    + Look for player and apply small vector to adjust towards current location
* Once the cannon is destroyed, go to the next level
  - Player gets an extra ship
  - In each level, things move faster
* Create a World class
  - Move stars into this
* Abstract drawing library
  - (DONE) Decide about linking to librsvg vs. copying in rsvg-path.c, etc.
  - Examine if some code could benefit from 2geom calls
  - Study rsvg_cairo_render_path for possible reuse
* Levels
  - Keep track of level number
  - On death of cannon, go to next level
  - Restore energy to max
  - Adapt game parameters to vary by level
    + Shield rotational speed
    + Cannon rotation speed
    + Firing speed of cannon
    + Missile speed
    + Homing mines speed
    + Number of homing mines
* Conceptualize sound system and plan adding sound engine


Cairo-based 2D Game Engine
=======
* Overview/principles
  - Open Source
  - Linux
  - 2D only, using Cairo
  - C++/Gtk
  - Purpose is for games, but could also feed back into inkscape?
* Decide license:  LGPL or GPL
* Consider alternate names to inkdrop
* Build System
  - Look up how to do default autoconf stuff from scratch
  - Decide autoconf vs cmake
  - Provide a ./configure
  - Add icons
* Scene Graph
  - Read http://en.wikipedia.org/wiki/Scene_graph
* (DONE) Create super-project in launchpad - terranova
  - Mark spacecastle as part of this project
  - Establish a mailing list
  - Decide how to merge/split the code
* Be able to specify an arbitrary Inkscape SVG file to load and use as
  the ship
* Review existing game engines
  - How are other games / libs packaged/organised in Ubuntu?
  - Read http://wiki.gamedev.net/index.php/Template:C_plus_plus:Tutorials
  - Read http://wiki.gamedev.net/index.php/Programming_Techniques:Double_Dispatch
  + SDL
  + CrystalSpace
  + ClanLib
  + Ogre3D
  + Irrlicht
  + ika
  + Blox Game Engine (Windows)
  + http://jengine.homedns.org/
  + http://www.thousandparsec.net/
  + http://www.zakengine.com/
  + http://edge2d.googlecode.com/
* Decide overall architecture
  - Engine architecture
    + Each subsystem allows doing a variety of low level things with one
      API call
  - Graphics Core:  Cairo Renderer
    + Perhaps derive from librsvg
    + Animation
    + Font
  - Input Core
  - Sound Core
  - System Core - http://wiki.gamedev.net/index.php/SDL:Tutorials:Complete_2D_Engine_System_Core
    + Window App manager
    + Process Manager
    + Game State Manager
      - Intro, main menu, main game
      - Push/Pop states onto the stack to move from state to state
      - Process() the current state
  - Networking Core
  - Resources
    + Load from data files (xml?)
    + References to other files
    + Should custom gfx be external or embedded?
    + Could I use SVG for the entire resource data file?  Then this
      would enable using Inkscape itself as the principle game editor
* GUI Library
  - Examples
    + Health bars
    + Inventory display
    + Current level
    + Game over messages
    + High score display
  - Widgets
    + Input Boxes
    + Scrollbars
    + Combo Boxes
    + Menus
    + List boxes
    + Checkboxes
    + Buttons
  - Customized styles (XUL?)
* Misc
 - Top level game framework/manager
    + Game parameters loading / storage
    + Level management
    + Game tick management
    + Keyboard management
  - Game World class structure
    + Space vs. rooms vs. scrolling vs. platform
  - SVG-loading routines
  - Generalized cairo-based drawing
    + Paths
    + Stars
    + Arcs
    + Flares
    + Clouds
    + Cones
  - Scoring system
  - 2D kinetics and collision physics
    + http://clanlib.org/docs/clanlib-0.8.0/Overview/collision_detection.html
  - Clock (from gnome-games libgames-support?)
  * Review ~/src/Games/Archive/WorldForge/forge/servers/stage/math/ for
    anything that duplicates to 2geom and/or could be moved there

Game Component Library
======================
  - Separate
  - Provides reusable "chunks" of game code, resources and logic
  - Stock game elements to reuse for quick game creation
    + Spaceship
    + Missile
    + Dragon
    + Warrior
    + City
    + Train
  - Sprite Animation Effects
    + Color/transparency variation
    + Spinning/rotating
    + Scaling
    + Node translation
    + Node control changing
    + Path-based movement relative to sprite center
    + Grouping multiple sub-parts into a single entity
    + Use graphical "effect" markers to design the above effects
  - World Elements
    + background elements (stars for space)
    + Terrain tiles
    + settlements
  - Unit for strategy games
    + attack/defense strengths
    + movement rates
    + energy / hp
    + spotting ranges
  - Stock logic
    + World generator
    + Recipe-based object conversions
    + Diplomacy
    + Trading
    + Inventory management
    + Unit design (ala Alpha Centauri)
  * Things to evaluate
    - http://code.google.com/p/google-gflags - Commandline flags module
    - http://code.google.com/p/google-perftools
    - http://code.google.com/p/google-sparsehash

Later
=====
* Integrate librsvg(?)
* Integrate ODE (www.ode.org)
* Integrate Lua
* Integrate SVG+JS DOM library 
* Integrate 2geom
* http://www.openclipart.org/cgi-bin/navigate/signs_and_symbols/map_symbols?page=8

